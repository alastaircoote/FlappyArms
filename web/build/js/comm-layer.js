(function(){var t=function(t,e){return function(){return t.apply(e,arguments)}},e={}.hasOwnProperty,n=function(t,n){function o(){this.constructor=t}for(var i in n)e.call(n,i)&&(t[i]=n[i]);return o.prototype=n.prototype,t.prototype=new o,t.__super__=n.prototype,t};define(["libs/peer","libs/socketio","servers","libs/microevent","logger"],function(e,o,i,r,c){var s;return s=function(r){function s(){this.disconnect=t(this.disconnect,this),this.socketDisconnected=t(this.socketDisconnected,this),this.webRtcDisconnected=t(this.webRtcDisconnected,this),this.send=t(this.send,this),this.logHeartbeat=t(this.logHeartbeat,this),this.sendHeartbeat=t(this.sendHeartbeat,this),this.setRTCConnection=t(this.setRTCConnection,this),this.receiveSocket=t(this.receiveSocket,this),this.connectWebRTC=t(this.connectWebRTC,this),this.connectSocketIO=t(this.connectSocketIO,this),this.on("receive",this.logHeartbeat)}return n(s,r),s.prototype.SupportsWebRTC=util.supports.data,s.prototype.connectSocketIO=function(t){var e;return this.serverIndex=t,(e=i.socketio[t])?(c.info("Mapped socket.io server index "+t+" to "+e),this.socket=o.connect(e),this.socket.on("receive",function(t){return function(e){return t.receiveSocket(e)}}(this)),this.socket.on("disconnect",function(t){return function(){return t.socketDisconnected()}}(this)),this.socket.on("connect",function(t){return function(){return c.info("Connected to socket.io server"),t.trigger("socketio-connected"),t.connectWebRTC()}}(this))):this.trigger("badserver")},s.prototype.connectWebRTC=function(){return this.SupportsWebRTC?(this.peer=new e({host:i.webrtc[this.serverIndex],port:5001,path:"/"}),this.peer.on("connection",function(t){return function(e){return t.setRTCConnection(e)}}(this)),this.peer.on("error",function(t){return function(){return c.info("Unable to reach peering server. Falling back to socket.io..."),t.trigger("connections-complete")}}(this)),this.peer.on("close",function(){return function(){return c.info("Disconnected from peering server")}}(this)),c.info("Browser supports WebRTC data, connecting to server..."),this.peer.on("open",function(t){return function(e){return c.info("Received WebRTC PeerId "+e+"."),t.trigger("webrtc-connected",e),t.trigger("connections-complete"),$("#spanConnMethod").html("WebRTC")}}(this))):(this.trigger("connections-complete"),c.info("Browser does not support WebRTC data :("))},s.prototype.receiveSocket=function(t){var e;return"host-attached"===t.ev&&t.peerId&&this.SupportsWebRTC?(c.info("Attempting to connect via WebRTC..."),e=this.peer.connect(t.peerId),void e.on("open",function(n){return function(){return n.setRTCConnection(e),n.trigger("receive",t)}}(this))):this.trigger("receive",t)},s.prototype.setRTCConnection=function(t){return this.peerConnection=t,c.info("Successfully established WebRTC connection"),this.peerConnection.on("data",function(t){return function(e){return t.trigger("receive",e)}}(this)),this.peerConnection.on("close",function(t){return function(){return t.webRtcDisconnected()}}(this)),this.peerConnection.on("error",function(){return function(t){return console.log("error",t)}}(this)),this.heartbeatInterval=setInterval(function(t){return function(){return t.sendHeartbeat()}}(this),1e3),this.useWebRTC=!0,this.socket.disconnect()},s.prototype.sendHeartbeat=function(){return this.lastHeartbeat&&this.lastHeartbeat<Date.now()-3e3&&(this.lastHeartbeat=null,this.peerConnection.close(),this.peer.destroy(),clearInterval(this.heartbeatInterval)),this.peerConnection.send({ev:"heartbeat",time:Date.now()})},s.prototype.logHeartbeat=function(t){return"heartbeat"===t.ev&&(this.lastHeartbeat=t.time),t.time?this.trigger("ping",Date.now()-t.time):void 0},s.prototype.send=function(t){return this.useWebRTC?this.peerConnection.send(t):this.socket.emit("send",t)},s.prototype.webRtcDisconnected=function(){return c.info("WebRTC connection closed."),this.trigger("disconnected")},s.prototype.socketDisconnected=function(){return c.info("Closed socket.io connection."),o.j=[],o.sockets=[],this.useWebRTC?void 0:this.trigger("disconnected")},s.prototype.disconnect=function(){return this.socket?this.socket.disconnect():void 0},s}(r)})}).call(this);